/*
 * Copyright (C) 2011,2012 Daniel Thomas (drt24)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.nigori.client;

import static com.google.nigori.common.MessageLibrary.toBytes;
import static org.junit.Assert.assertArrayEquals;

import org.junit.BeforeClass;
import org.junit.Test;

import com.google.nigori.common.NigoriCryptographyException;

/**
 * @author drt24
 * 
 */
public class RealKeyManagerTest extends AbstractKeyManagerTest {

  @Override
  protected KeyManager getKeyManager(String serverName, byte[] userName, byte[] password)
      throws NigoriCryptographyException {
    return new RealKeyManager(serverName, userName, password);
  }

  @Override
  protected KeyManager getKeyManager(String serverName) throws NigoriCryptographyException {
    return new RealKeyManager(serverName);
  }

  @Test
  public void pbkdf2() throws NigoriCryptographyException {
    for (PbkdfTestCase testCase : pbkdfTestCases) {
      byte[] answer =
          RealKeyManager.pbkdf2(testCase.password, testCase.salt, testCase.rounds,
              testCase.outputBytes);
      // System.out.println(Arrays.toString(answer));
      assertArrayEquals(testCase.answer, answer);
    }
  }

  // Answers generated by using System.out.println above to get the values we were generating on
  // 2012-12-17 which are hopefully correct.
  private static byte[] passwordSaltAnswer = {
      -123, -107, -41, -82, -96, -25, -55, 82, -93, 90, -7, -88, 56, -52, 107, 57};
  private static byte[] testTestAnswer = {
      15, 115, -68, -18, -19, 46, -17, 41, 9, -2, -31, 62, 95, -6, -78, -112};
  private static byte[] aaAnswer = {
      -32, 52, 55, -111, -68, -49, -83, 34, -116, -61, 59, -64, -17, -3, -94, -108};
  private static byte[] passwordSaltAnswer1000 = {
      110, -120, -66, -117, -83, 126, -82, -99, -98, 16, -86, 6, 18, 36, 3, 79};
  private static byte[] testTestAnswer1000 = {
      120, 95, 112, -100, 17, 50, -77, 67, -77, 47, -101, -26, 71, -13, -121, 24};
  private static byte[] aaAnswer1000 = {
      127, -101, -127, -29, 64, -37, 95, -43, 19, -16, -70, 23, -47, -10, 113, -66};

  // TODO(drt24) add the test vectors from the pbkdf RFC

  private static PbkdfTestCase[] pbkdfTestCases = {
      new PbkdfTestCase(toBytes("password"), toBytes("salt"), 100, 16, passwordSaltAnswer),
      new PbkdfTestCase(toBytes("test"), toBytes("test"), 100, 16, testTestAnswer),
      new PbkdfTestCase(toBytes("a"), toBytes("a"), 100, 16, aaAnswer),
      new PbkdfTestCase(toBytes("password"), toBytes("salt"), 1000, 16, passwordSaltAnswer1000),
      new PbkdfTestCase(toBytes("test"), toBytes("test"), 1000, 16, testTestAnswer1000),
      new PbkdfTestCase(toBytes("a"), toBytes("a"), 1000, 16, aaAnswer1000)};

  private static class PbkdfTestCase {
    final byte[] password;
    final byte[] salt;
    final byte[] answer;
    final int rounds;
    final int outputBytes;

    public PbkdfTestCase(byte[] password, byte[] salt, int rounds, int outputBytes, byte[] answer) {
      this.password = password;
      this.salt = salt;
      this.rounds = rounds;
      this.outputBytes = outputBytes;
      this.answer = answer;
    }
  }

  private static KeyManager testKeyManager;

  @BeforeClass
  public static void keyManger() throws NigoriCryptographyException {
    testKeyManager = new RealKeyManager("test", toBytes("test"), toBytes("test"));
  }

  private static class EncryptionTestCase {
    final byte[] plaintext;
    final byte[] answer;
    final KeyManager keyManager;

    public EncryptionTestCase(byte[] plaintext, byte[] answer, KeyManager keyManager) {
      this.plaintext = plaintext;
      this.answer = answer;
      this.keyManager = keyManager;
    }
  }

  // Test case generated by just running the current code on 2012-12-19
  private static byte[] detEncTestPlaintext = {
      -87, -64, 101, 73, 55, -23, 111, 34, -25, 112, 94, -114, -29, -56, 79, -106, 103, -107, 91,
      123, -107, -43, 95, -75, -71, -35, -30, -4, 95, -91, -128, -87, 52, -93, 98, -39, -25, 20,
      15, -57, -56, -78, -30, -4, 109, -125, 116, 27, 32, -63, 52, 37, -22, -9, 36, -31, -31, 123,
      39, -97, 37, 101, -94, -50};
  private EncryptionTestCase[] detEncryptionTestCases = {new EncryptionTestCase(
      toBytes("plaintext"), detEncTestPlaintext, testKeyManager)};

  @Test
  public void encryptDeterministically() throws NigoriCryptographyException {
    for (EncryptionTestCase testCase : detEncryptionTestCases) {
      assertArrayEquals(testCase.answer,
          testCase.keyManager.encryptDeterministically(testCase.plaintext));
    }
  }
}
